# 数据库目录创建方案

## 目标

- 保留 `apps/backend/sequelize/` 作为 CLI（迁移/种子/模型工厂）目录
- 在 `apps/backend/src/databases/` 建立运行时适配层，统一加载模型与关联，向服务层导出 `Models`

## 结构

- `apps/backend/src/databases/index.ts`：入口，导出 `{ sequelize, models, modelsReady, dbInstance }`
- `apps/backend/src/databases/loaders/loadModels.ts`：动态导入 CLI 模型工厂并实例化
- `apps/backend/src/databases/loaders/setupAssociations.ts`：执行 `associate` 建立关联
- （可选）`apps/backend/src/databases/repositories/baseRepository.ts`：通用 CRUD 模板

## 连接与装配

- 连接源：`apps/backend/src/database.ts`（连接池/日志/benchmark）
- 加载流程：`loadModels(sequelize)` → `setupAssociations(models)` → 暴露 `modelsReady`
- 控制器装配：`initializeControllers` 等待 `modelsReady` 并注册到 `ServiceFactory`

## 类型与约束

- 统一类型契约：`apps/backend/src/types/models.ts` 的 `Models/DatabaseInstance`
- 补齐类型：`SubCourse/CourseTeacher/HomeworkFile` 模型接口与 `Models` 成员
- 字段命名：ORM 层使用 `snake_case`，业务层 `camelCase`，映射在服务层完成

## 与 CLI 目录的关系

- 不复制模型定义与关联；仅调用 CLI 工厂并执行其 `associate`
- CLI 保持迁移/种子工作流不变；运行时统一连接来源，避免双连接与配置漂移

## 验证

- 全量类型检查通过
- 路由与服务层保持不变，`ServiceFactory` 正常获取模型
- 输出类型兼容性验证报告

## 风险与规避

- 路径差异：使用 `fileURLToPath + path.resolve` 动态定位 CLI 模型目录
- 类型缺口：补齐引用模型接口，确保编译通过
